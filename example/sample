// m: [100 f32]! {0}

// j: m + 2


x: 10 + 20


// z: {
// 	10
// }

// q: a: {
// 	x: 2
// 	b: {
// 		d: 2
// 		e: 5
// 	}
// 	c: {
// 		g: 7
// 		h: 9
// 	}
// }

// k: a.b.d

// k: a.b
// k: a.b.c

// a: 12 ![i32]

// array: {1,2,3}
// j: array#[1]

// a: b: 12
// 10 + 20
// x: 3

// // Point: { x: y: 0, time: 100ns }
// Point: { x: 2 }

// myval: {
// 	// a: 10
// 	Point { x: a } + Point { x } + Point {}
// }

// jeff: 10 + 9

// myarray: { 1, 2, bob: 10, (jeff), tim: 20 }
// //
// bob: { a: b: [10 i32] -> a + b }
// rob: { c: d: 0 -> c - d }

// quad: {
// 	a: b: c: [f32]
// 	disc: b^2 - 4*a*c
// 	root: Sqrt(disc)
// 	deno: 2*a

// 	neg: (-b - rooted) / deno
// 	pos: (-b + rooted) / deno
// }

// c: count(100ms)

// a: 12, b: 13
// c: a + b

// a: 12

// bob: {
// 	a: b: 0 //[i32]
// 	Point {x, y} :: Point {
// 		x: a
// 		y: b
// 	}
// -> a + b
// }

// a: [i32]! 12
// a: signal ? [i32]! 23
// a: signal ? 23 ![i32]
// a: [i32]! signal ? 23

// a: b: c: 10 & 9 + 2 * 2 | 20 ^ - 2 | #30
// d: a: b ^ 2 - 4 * a * c

// b: b ^ 2 - 4 * a * c
// a {}, arg . b

// tom: bob: hello, bob . jeff

// a: {
// 	a: 10 b: 20
// 	c: 30}

// symbols: { :a, :b, :c }

// signal ? boolean: `a & b | a & `b | `c

// + : {
// 	a: 10
// 	b: 20	+ : 10
// }
// +: 10
// quadratic: {
// 	signal ? a: b: c: [10,f64]

// 	discriminant: b^2 - 4*a*c
// 	rooted: Sqrt { discriminant }
// 	denominator: 2*a

// 	positive: (-b + rooted) / denominator
// 	negative: (-b - rooted) / denominator
// }

// (quadratic: {
// 	(? signal (a: (b: (c: [10 f64]))))

// 	(discriminant: (- (^ b 2) (* 4 a c)))
// 	(rooted: (Sqrt{ discriminant }))
// 	(denominator: (* 2 a))

// 	(positive: (/ (+ (-b) rooted) denominator))
// 	(negative: (/ (- (-b) rooted) denominator))

// 	(-> {positive negative})
// })

// Math: {
// 	Point: {a: i32, b: i32}
// 	point: {
// 		(+): { a: b: Point -> Point{a.a + a.b, b.a + b.b} }
// 		(-): { a: b: Point -> Point{a.a - a.b, b.a - b.b} }
// 		(*): { a: b: Point -> Point{a.a * a.b, b.a * b.b} }
// 		(/): { a: b: Point -> Point{a.a / a.b, b.a / b.b} }
// 	}

// 	Vec'3: {x: y: z: 0}
// 	vec'3: {
// 		add: { a: b: Vec'3 -> a + b }
// 		sub: { a: b: Vec'3 -> a - b }
// 		mul: { a: b: Vec'3 -> a * b }
// 		div: { a: b: Vec'3 -> a / b }
// 	}
// }

// a: b [u64] ~ Point {x,y} : operation

// a: b [u64]

// set: { red; orange; yellow; green; red; blue; }
